《领域驱动设计-软件核心复杂性应对之道》  

前言
    至少20年前，一些顶尖的软件设计人员就已经认识到领域建模和设计的重要性，但令人惊讶的是，这么长时间以来几乎没有人写出点儿什么，告诉大家应该做哪些工作或如何去做。尽管这些工作还没有被清楚的表述出来，但一种新的思潮已经形成，它像一股暗流一样在对象社区中涌动，我把这种思潮称为领域启动设计（domian-driven design）。

本书的结构（4个部分）：

第一部分（运用领域模型）：1、消化知识， 2、交流与语言的使用， 3、绑定模型和实现
-- 提出领域驱动开发的目标，这些目标是后面几部分所讨论的实践的驱动因素。由于软件开发方法有很多，因此第一部分还定义了一些术语，并给出了用领域模型来驱动沟通和设计的总体含义。

第二部分（模型驱动设计的构造块）：4、分离领域， 5、软件中所表示的模型， 6、领域对象的生命周期， 7、使用语言：一个扩展的示例
-- 将面向对象领域建模中的一些核心的最佳实践提炼为一组基本的构造块。这一部分主要是消除模型与实际运行的软件之间的鸿沟。团队一致使用这些标准模式就可以使设计井然有序，并且使团队成员更容易理解彼此的工作。

第三部分（通过重构来加深理解）：8、突破， 9、将隐式概念转变为显示概念， 10、柔性设计， 11、应用分析模式， 12、将设计模式应用于模型， 13、通过重构得到更深层的理解
-- 讨论如何将构造块装配为实用的模型，从而实现其价值。这里着重强调一个发现过程。有价值的模型不是立即就会出现的，它们需要对领域的深入理解。这种理解是一步一步得到的，首先需要深入研究模，然后基于最初的（可能是不成熟的）模型实现一个初始设计，再反复改进这个设计。探索本身是永无止境的，但这并不意味它是随机的。第三部分深入阐述一些指引我们保持正确方向的建模规则，并提供了一些指导我们进行探索的方法。

第四部分（战略设计）：14、保持模型的完整性， 15、精炼， 16、大型结构， 17、领域驱动的综合运用
-- 讨论在复杂系统、大型组织以及与外部系统与遗留系统的交互中出现的复杂情况。这一部分探讨了作为一个整体应用于系统的3条原则：上下文、提炼和大型结构。


第一章 消化知识
1. 有效建模的要素：a、模型和实现的绑定 b、建立一种基于模型的语言 c、开发一个蕴含丰富知识的模型 d、提炼模型 e、头脑风暴和实践
2. 知识消化并不是一项孤立的运动，它一般是在开发人员的领导下，由开发人员与领域专家组成的团队来共同协作；知识消化是一种探索，它永无止境

第二章 交流与语言的使用
1. 要想创建一种灵活的，蕴含丰富知识的设计，需要一种通用的、共享的团队语言，以及对语言不断的实验 -- 然而，软件项目上很少出现这样的试验
2. 将模型作为语言的支柱。确保团队在内部的所有交流中以及代码中坚持使用这种语言。在画图、写东西，特别是讲话时也要使用这种语言
3. 通过尝试不同的表示方法来消除难点。然后重构代码，重新命名类，方法和模块，以便于新模型保持一致。解决交谈中的术语混淆问题，就像我们对普通词汇形成一致的理解一样。
4. 讨论系统时要结合模型。使用模型元素及其交互来大声描述场景，并且按照模型允许的方式将各种概念结合到一起。找到更简单的表达方式来讲出你要讲的话，然后按照这些新的想法应用到图和代码中。
5. a、设计的重要细节应该在代码中体现出来 b、文档应作为代码和口头交流的补充 c、文档不应该重复表示代码已经明确表达出的内容 d、文档应当鲜活并保持最新 e、文档必须深入到各种项目活动中去 
6. 本书的核心思想是在实现、设计和团队交流中使用同一个模型作为基础。

第三章 绑定模型和实现
1. 领域驱动设计要求模型不仅能够指导早期的分析工作，还应该成为设计的基础。严格按照基础模型来编写代码，能够使代码更好地表达设计含义，并且使模型与实际的系统向契合。无论是什么原因，软件的设计如果缺乏概念，那么软件充其量不过是一种机械化的产品 -- 只实现有用的功能却无法解释操作的原因。
2. 如果整个程序设计或者核心部分没有与领域模型相对应，那么这个模型就是没有价值的，软件的正确性也值得怀疑。同时，模型和设计功能之间过于复杂的对应关系也是难于理解的，在实际项目中，当设计改变时也无法维护这种关系。若分析和设计之间产生严重分歧，那么在分析和设计活动中所获得的知识就无法彼此共享。
3. 人们总是把软件开发比喻成制造业。这个比喻的一个推论是：经验丰富的工程师做设计工作，而技能水平较低的劳动力负责组装产品。这种做法使许多项目陷入困境，原因很简单-- 软件开发就是设计。虽然开发团队中的每个成员都有自己的职责，但是将分析、建模、设计和编程工作过度分离会对Model-Driver-Design产生不良影响。
4. 任何参与建模的技术人员，不管在项目中的主要职责是什么，都必须花时间了解代码。任何负责修改代码的人员则必须学会用代码来表达模型。每一个开发人员都必须不同程度低参与模型讨论并且与领域专家保持联系。参与不同工作的人都必须有意识地通过UbiquitousLanguage与接触代码的人及时交换关于模型的想法。
5. 将建模和编程过程完全分离是行不通的，然而大型项目依然需要技术负责人来协调高层次的设计和建模，并帮助做出困难或最关键的决策。本书的第四部分描述的就是这种决策，通过学习该部分内容可以激发灵感，找到更高效的方法来定义高级技术人员的角色和职责。


第四章 分离领域
1. 在面向对象的程序中，常常会在业务对象中直接写入用户界面、数据库访问等支持代码。而一些业务逻辑则会被嵌入到用户界面组件和数据库脚本中。这么做是为了以最简单的方式在短期内完成开发工作。如果与领域有关的代码分散在大量的其他代码之中，那么查看和分析领域代码就会变得异常困难。对用户界面的简单修改实际上很可能会改变业务逻辑，而想要调整业务规则也很可能需要对用户界面代码、数据库操作代码或者其他的程序元素进行仔细的筛查。这样就不太可能实现一致的、模型驱动的对象了，同时也会给自动化测试带来困难。
2. 要想创建出能够处理复杂任务的程序，需要做到关注点分离 -- 设计中的每个部分都得到单独的关注。在分离的同时，也需要维持系统内部复杂的交互关系。分层的价值在于每一层都只代表程序中的某一特定方面。这种限制使每个方面的设计都更具内聚性，更容易解释。
3. 选择恰当的分层方式是直观重要的。经验和惯例又一次给我们指明了方向。Layered Architecture的种类繁多，但大多成功的架构使用的都是下面这4概念层的某种变体
	用户界面层（或表示层）：负责向用户显示信息和解释用户指令。这里指的用户可以是另一个计算机系统，不一定是使用用户界面的人。
	应用层：定义软件要完成的任务，并且只会表达领域概念的对象来解决问题。这一层所负责的工作对业务来说意义重大，也是与其他系统的应用层进行交互的必要渠道。
	领域层（或模型层）：负责表达业务概念，业务状态信息以及业务规则。尽管保存业务状态的技术细节是由基础设施层实现的，但反应业务情况的状态是由本层控制并且使用的。领域层是业务软件的核心。
	基础设施层：为上面各层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件，等等。基础设施层还能够通过架构框架来支持4个层次间的交互模式。
4. 给复杂的应用程序划分层次。在每一层内分别进行设计，使其具有内敛型并且只依赖于它的下层。采用标准的架构模式，只与上层进行松散的耦合。将所有与领域模型相关的代码放在一个层中，并把它与用户界面层、应用层以及基础设施层的代码分开。领域对象应该将重点放在如何表达领域模型上，而不需要考虑自己的显示和存储问题，也无需管理应用任务等内容。这使得模型的含义足够丰富，结构足够清晰，可以捕捉到基本的业务知识，并有效地使用这些知识。
5. 各层之间是松散连接的，层与层的依赖关系只能是单向的。上层可以直接使用或操作下层元素，方法是通过调用下层元素的公共接口，保持对下层元素的引用（至少是暂时的），以及采用常规的交互手段。而如果下层元素需要与上层元素进行通信（不只是回应直接查询），则需要采用另一种通信机制，使用架构模式来连接上下层，如回调模式或Obervers模式。
6. 通常，基础设施层不会发起领域层的操作，它处于领域层“之下”，不包含其所服务的领域层的知识。事实上这种技术能力最场以SERVICE的形式提供。应用层和领域层可以调用基础设施层锁提供的SERVICE。如果SERVICE的范围选择合理，接口设计完善，那么通过把详细行为封装到服务接口中，调用程序就可以保持与SERVICE的松散连接，并且自身也会很简单。

第五章 软件中所表示的模型
1. 对象之间的关联使得建模与实现之间的交互更为复杂 - 模型中每个可遍历的关联，软件中都要有同样属性的机制。
2. 很多对象不是通过它们的属性定义的，而是通过连续性和标识定义的。
3. 当一个对象由其标识（而不是属性）区分时，那么在模型中应该主要通过标识来确定该对象的定义。使类定义变得简单，并集中关注生命周期的连续性和标识。定义一种区分每个对象的方式，这种方式应该与其形式和历史无关。要格外注意哪些需要通过属性来匹配对象的需求。在定义标识操作时，要确保这种操作为每个对象生成的唯一结果，这个可以通过附加一个保证唯一性的符号来实现。这种定义标识的方法可能来自外部，也可能是由系统创建的任意标识符，但它在模型中必须是唯一的标识。模型必须定义出 “符合审美条件才算是相同的事务”。
4. 当我们只关心一个模型元素的属性时，应把它归类为Value Objetc。我们应该使这个模型元素能够表示出其属性的意义，并为它提供相关功能。Value Object应该是不可变的。不要为它分配任何标识，而且不要把它设计成像Entity那么复杂。
5. Service是作为接口提供的一种操作，它在模型中是独立的，它不想Entity和Value Object那样具有封装的状态。Service是技术框架中的一种常见模式，但它也可以在领域层中使用。好的Service有以下3个特征：a、与领域概念相关的操作不是Entity或Value Object的一个自然组成部分， b、接口是根据领域模型的其他元素定义的， c、操作是无状态的
6. 像领域驱动设计中的其他元素一样，Module是一种表达机制。Module的选择应该取决于被划分到模块中的对象的意义。当你将一些类放到Module中时，相当于告诉下一位看到你的设计的开发人员要把这些类放在一起考虑。如果说模型讲述了一个故事，那么Module就是这个故事的各个章节。模块的名称表达了其意义。这些名称应该被添加到Unbiquitous Language中。

第六章 领域对象的生命周期
1. 每个对象都有生命周期。对象自创建后会经历各种不同的状态，直至消亡--要么存档，要么删除。很多对象是简单的临时对象，最后由垃圾收集器回收。但有些对象有更长的生命周期，与其他对象具有复杂的相互依赖性。他们会经历一些状态变化，在变化时要遵守一些固定规则。管理这些对象主要面临以下两类挑战：a、在整个生命周期中维护完整性， b、防止模型陷入管理生命周期复杂性造成的困境当中。
2. 本章通过3中模式解决这些问题。首先是Aggregate（聚合），它通过定义清晰的所属关系和边界，并避免混乱、错综复杂的对象关系网来实现模型的内聚。接下来，聚焦到生命周期的开始阶段，使用Factory（工厂）来创建和重建复杂对象和Aggregate（聚合），从而封装它们的内部结构。最后，在生命周期的中间和末尾使用Repository（存储库）来提供查找和检索持久化对象并封装庞大基础设施的首段。
3. 当创建一个对象或创建整个Aggregate时，如果创建工作很复杂，或者暴露了过多的内部结构，则可以使用Factory进行封装
4. 对象的创建本身可以是一个主要操作，但被创建的对象并不适合承担复杂的装配操作。将这些职责混在一起可能产生难以理解的拙劣设计。让客户直接负责创建对象又会使客户的设计陷入混乱，并且破坏被装配对象或Aggregate的封装，而导致客户与被创建对象的实现之间产生过于紧密的耦合。
5. 因此，应该将创建复杂对象的实例和Aggregate的职责转移给单独的对象，这个对象本身可能没有承担领域模型中的职责，但它仍是领域设计的一部分。提供一个封装所有复杂装配操作的接口，而且这个接口不需要客户应用要被实例化的对象的距离类。在创建Aggregate时要把它作为一个整体，并确保它满足固定规则。


第七章 使用语言：一个扩展的实例
1. 货物运输系统简介
2. 隔离领域：引入应用层
3. 将Entity和Value Object区别开
4. 设计运输领域中的关联
5. Aggregate边界
6. 选择Repository
7. 场景走查
8. 对象的创建
9. 停一下 -- 重构
10. 运输模型中的Module
11. 引入新特性：配额检查
12. 小结

第八章 突破
1. 重构的投入与回报并非呈线性关系。通常，小的调整会带来小的回报，小的改进也会积少成多。一般来说，持续重构让事务逐步变得有序。代码和模型的每一次精化都让开发人员有了更加清晰的认知。这使得理解上的突破称为可能。之后，一系列快速的改变得到了更符合用户需要并更加切合实际的模型。其功能性及说明性急速增强，而复杂性却随之消失。
2. 当突破带来更深层的模型时，通常会令人感到不安。与大部分重构相比，这种变化的回报更多，风险也更高。而且突破出现的时机可能很不合时宜。
3. 不要试图去制造突破，那只会使项目陷入困境。通常，只有在实现了许多适度的重构后才有可能出现突破。在大部分时间里，我们都在进行微小的改进，而在这种连续的改进中模型深层含义也会逐渐显现。
4. 不要犹豫着不去做小的改进，这些改进即使脱离不开常规的概念框架，也可以逐渐加深我们对模型的理解。不要因为好高骛远而使项目陷入困境。只要随时注意可能出现的机会就够了。

第九章 将隐式概念转变为显示概念
1. 若开发人员识别出设计中隐含的某个概念或是讨论中收到启发而发现一个概念时，就会对领域模型和相应代码进行许多转换，在模型中加入一个或多个对象关系，从而将此概念显示的表达出来。有时，这种从隐式概念到显示概念的转换可能是一次突破，使我们得到一个深层模型。但更多的时候，突破不会马上到来，而需要我们在模型中显示表达出许多重要概念，并通过一系列重构不断调整对象职责，改变它们与其他对象的关系、甚至多次修改对象名称，在这之后，突破才会姗姗而来。
2. 倾听领域专家使用的语言。有没有一些术语能够简洁地表达出复杂的概念？他们有没有纠正过你的用词（也许是很委婉的提醒）？当你使用某个特定词语时，他们脸上是否已经不再流露出迷惑的表情？这些都暗示了某个概念也许可以改进模型。
3. 如果约束的存在掩盖了对象的基本职责，或者如果约束在领域中非常突出但在模型中却不明显，那么就可以将其提取到一个显示的对象中，甚至可以把它建模为一个对象和关系的集合。
4. 将过程建模为领域对象 -- 需要说明的是，我们都不希望过程变成模型的主要部分。对象时用来封装过程的，这样我们只需考虑对象的业务目的或意图就可以了。我们必须在模型中把这些过程表示出来，否则当这些过程显露出来是，往往会使对象设计变得笨拙。
5. 如果过程的执行有多种方式，那么我们也可以用另一种方法来处理它，那就是将算法本身或其中的关键部分放到一个单独的对象中。这样，选择不同的过程就变成了选择不同的对象，每个对象都表示一种不同的Strategy。
6. 过程是应该被显示表达出来，还是应该被隐藏起来呢？区分的方法很简单：它是经常被领域专家提起呢，还是仅仅被当做计算机程序机制的一部分？

第十章 柔性设计
1. 软件的最终目的是为用户服务。但首先它必须为开发人员服务。为了使项目能够随着开发工作的进行加速前进，而不会由于它自己的老化停滞不前，设计必须要让人们乐于使用，而且易于做出修改。这就是柔性设计（supple design）
2. 柔性模式是对深层建模的补充。一旦我们挖掘出隐式概念，并把它们显示地表达出来之后，就有了原料。通过迭代循环，我们可以把这些原料打造成有用的形式：建立的模型能够简单而清晰地捕获主要关注点；其设计可以让客户开发人员真正使用这个模型。在设计和开发过程中，我们将获得新的理解，并通过这些理解改善模型概念。我们一次又由此回到迭代循环中，通过重构得到更深刻的理解。
3. 在命名类和操作时要描述它们的效果和目的，而不要表露它们是通过何种方式达到目的的。这样可以使客户开发人员不去理解内部细节。这些名称应该与Ubiquitous Language保持一致，以便团队成员可以迅速推断出它们的意义。在创建一个行为之前先为它编写一个测试，这样可以促使你站在客户开发人员的角度上来思考它。
4. 所有复杂的机制都应该在封装到抽象接口的后面，接口只表明意图，而不表明方式。在领域公共接口中，可以把接口和规则表述出来，但不要说明规则是如何实施的；可以把事件和动作描述出来，但不要描述它们是如何执行的；可以给出方程式，但不要给出解方程式的数学方法。可以提出问题，但不要给出获取答案的方法。
5. 当多个规则的相互作用或计算的组合所产生的结果时很难预测的。开发人员在调用一个操作时，为了预测操作的结果，必须理解它的实现以及它所调用的其它方法的实现。如果开发人员不得不”揭开接口的面纱“，那么接口的抽象作用就受到了限制。如果没有了可以安全地预见到结果的抽象，开发人员就必须限制”组合爆炸“，这就限制了系统行为的丰富性。
6. 返回结果而不产生副作用的操作称为函数。一个函数可以被多次调用，每次调用都返回相同的值。一个函数可以调用其他函数，而不担心这种嵌套的深度。函数比那些有副作用的操作更易于测试。由于这些原因，使用函数可以降低风险。
7. 尽可能把程序的逻辑放到函数中，因为函数是只返回结果而不产生明显副作用的操作。严格地把命令（引起明显的状态改变的方法）隔离到不返回领域信息的，非常简单的操作中。当发现了一个非常适合承担复杂逻辑职责的概念时，就可以把这个复杂逻辑移到Value Object中，这样可以进一步控制副作用。
8. 通过反复重构最终会实现柔性设计，随着代码不断适应新理解的概念或需求，Conceptual Contour（概念轮廓）也就逐渐形成了。从单个方法的设计，到类和Module的设计，再到大型结构的设计，高内聚低耦合这一对基本原则都起着重要的作用。这两条原则既适用于代码，也适用于概念。为了避免机械化地遵循它，我们必须经常根据我们对领域的直观认识来调整技术思路。在做每个决定时，都要问自己：”这是根据当前模型和代码中的特定关系作出的权宜之计呢，还是反映了底层领域的某种轮廓？“
9. 把设计元素（操作、接口、类和Aggregate）分解为内聚的单元，在这个过程中，你对领域中一切重要划分的直观认识也要考虑在内。在连续的重构过程中观察发生变化和保证稳定的规律性，并寻找能够解释这些变化模式的底层概念轮廓。使模型与领域中那些一致的方面（正是这些方面使得领域成为一个有用的知识体系）相匹配。
10. 我们的目标是得到一组可以在逻辑上组合起来的简单接口，使我们可以用Ubiquitous Language进行合理的表述，并且使那些无关的选项不会分散我们的注意力，也不增加维护负担。但这通常是通过重构才能得到的结果，很难在前期就实现。而且如果仅仅是从技术角度进行重构，可能永远也不会出现这种结果；只有通过重构得到更深层的理解，才能实现这样的目标。
11. 在适当的情况下，在定义操作时让它的返回类型与其参数的类型相同。如果实现者（implementer）的状态在计算中会被用到，那么实现者实际上就是操作的一个参数，因此参数和返回值应该与实现者有相同的类型。这样的操作就是在该类型的实例集合中的闭合操作。闭合操作提供了一个高层接口，同时又不会引入对其他概念的任何依赖。

第十一章 应用分析模式 
1. 深层模型和柔性设计并非唾手可得。要想取得进展，必须学习大量领域知识并进行充分的讨论，还需要经历大量的尝试和失败。但有时我们也能从中获得一些优势。
2. 我们应该把所有分析模式的知识融入知识消化和重构的过程中，从而形成更深刻的理解，并促进开发。当我们应用一种分析模式时，所得到的结果通常与该模式的文献记载形式非常相像，只是因具体情况不同而略有差异。但有时完全看不出这个结果与分析模式本身有关，然而这个结果仍然是受该模式思想的启发而得到的。

第十二章 将设计模式应用于模型
1. 在《设计模式》中，有些模式可用作领域模式，但在这样使用的时候，需要变换一下重点。《设计模式》中的设计模式把相关设计元素归为一类，这些元素能够解决在各种上下文中经常遇到的问题，这些模式的动机以及模式本身都是从纯技术角度描述的。但这些元素中的一部分在更广泛的领域和设计上下文中也适用，因为这些元素所对应的基本概念在很多领域中都会出现。
2. 模式：Strategy -- 定义了一组算法，将每个算法分装起来，并使它们可以互换。
3. 当对过程进行建模时，我们经常会发现过程不止有一种合理的实现方式，而如果把所有的可选项都写到过程的定义中，定义就会变得臃肿而复杂，而且可供我们选择的实际行为也会因为混杂在其他行为中而显得模糊不清。我们希望把这些选择从过程的主体概念中分离出来，这样既能够看清主体概念，也能更清楚地看到这些选择。软件设计社区中众所周知的Strategy模式就是为了解决这个问题的，虽然它的侧重点在于技术方面。
4. 我们需要把过程中易变部分提取到模型的一个单独的“策略”对象中。将规则与它所控制的行为区分开。按照Strategy设计模式来实现规则或可替换的过程。策略对象的多个版本表示了完成过程的不同方式。通常，作为设计模式的Strategy侧重于替换不同算法的能力，而当其作为领域模式时，其侧重点则是表示概念的能力这里的概念通常是指过程或策略规则。
5. 定义一个把Composite的所有成员都包含在内的抽象类型。在容器上实现哪些查询信息的方法时，这些方法返回由容器内容所汇总的信息。而“叶”节点则基于它们自己的值来实现这些方法。客户只需要使用抽象类型，而无需区分“叶”和容器。

第十三章 通过重构得到更深层的理解
1. 有三件事是必须要关注的：a、以领域为本， b、用一种不同的方式来看待事物， c、始终坚持与领域专家对话
2. 开始重构： 获得深层理解的重构可能出现在很多方面。一开始有可能是为了解决代码中的问题（一段复杂或笨拙的代码）。与传统重构观点不同的是，即使在代码看上去很整洁的时候也可能需要重构，原因是模型的语言没有与领域专家保持一致，或者新需求不能被自然地添加到模型中。重构的原因也可能来自学习：当开发人员通过学习获得了更深刻的理解，从而发现了一个得到更清晰或更有用的模型的机会。
3. 探索团队：一些简单、明显的修改，可能只需几个小时即可完成。在这种情况下，所做的修改类似于传统重构。但寻找新模型可能需要更多时间，更多人参与。修改的发起者会挑选几位开发人员一起工作，这些开发人员应该擅长思考该类问题，了解领域，或者掌握深厚的建模技巧。如果涉及一些难以捉摸的问题，他们还要请一位领域专家加入。
4. 借鉴先前的经验：查找缺失概念或改进模型的头脑风暴、从书籍和领域自身的其他知识源获得思路、从分析模式中吸取他人的经验等都可以帮我们避免做一些无谓的重复工作。随着零散知识的归纳，必须同时处理模型关注点和设计关注点。同样，这并不意味着总是需要从头开发一切。当设计模式即符合实现需求，又符合模型概念时，通常就可以在领域层中应用这些模式。
5. 针对开发人员的设计：软件不仅仅是为用户提供的，也是为开发人员提供的。开发人员必须把它们编写的代码与系统的其他部分集成到一起。在迭代过程中，开发人员反复修改代码。开发人员应该通过重构得到更深层的理解，这样既能实现柔性设计，也能够从这样一个设计中获益。柔性设计主要通过减少依赖性和副作用来减轻人们的思考负担，这样的设计是以深层次的领域模型为基础的，在模型中，只有那些对用户最重要的部分才具有较细的力度。在这样的模型中，那些经常需要修改的地方能够保持很高的灵活性，而其他地方则相对比较简单。
6. 重构的时机：如果一直等到完全证明了修改的合理性之后采取修改，那么可能要等待太长时间了。项目正在承受巨大的耗支，推迟修改将使修改变得更难执行，因为要修改的代码已经变得更加复杂，并更深地嵌入到其他代码中。
7. 持续重构渐渐被认为是一种“最佳实践”，但大部分项目团队仍然对它抱有很大的戒心。人们虽然看到了修改代码有风险，还要花费开发时间，但却不容易看到维持一个拙劣设计也有风险，而且迁就这种设计也要付出代价。想要重构的开发人员往往被要求证明其重构的合理性。虽然这看似合理，但这使得一个本来就很难进行的工作变得几乎不可能完成，而且会限制重构的进行（或人们只能暗地里进行）。软件开发并不是一个可以完全预料到后果的过程，人们无法准确地计算出某个修改会带来哪些好处，或者不做某个修改会付出多大代价。
8. 在探索领域的过程中、在培训开发人员的过程中，以及在开发人员与领域专家进行思想交流的过程中，必须始终坚持把“通过重构得到更深层的理解”作为这些工作的一部分。因此，当发生以下情况时，就应该重构了：a、设计没有表达出团队对领域的最新理解；b、重要的概念被因此在设计中了（而且你已经发现了把它们呈现出来的方法）；c、发现了一个能令某个设计部分变得更灵活的机会。

第十四章 保持模型的完整性
1. 我们需要用一种方式来标记出不同模型之间的边界和关系。我们需要有意识地选择一种策略，并一致地遵守它。本章将介绍一些用于识别、沟通和选择模型边界及关系的技术。讨论首先从描绘项目当前的范围开始。Bounded Context(限定上下文)定义了每个模型的应用范围，而ContextMap（上下文图）则给出了项目上下文以及它们之间关系的总体视图。这些降低模糊性的技术能够使项目更好地进行，但仅仅有它们还是不够的。一旦确立了Context的边界之后，仍需要持续集成这种过程，它能够使模型保持统一。其后，在这个稳定的基础之上，我们就可以开始实施那些在界定和关联Context方面更有效的策略了 -- 通过共享内核（SharedKernel）来紧密关联上下文，到那些各行其道（SeparateWays）地进行松散耦合的模型。
2. 细胞之所以能够存在，是因为细胞膜限定了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜
3. 任何大型项目都会存在多个模型。而当基于不同模型的代码被组合到一起后，软件就会出现bug、变得不可靠和难以理解。团队成员之间的沟通变得混乱。人们往往弄不清楚一个模型不应该在哪个上下文中使用。因此，明确地定义模型所应用的上下文。根据团队的组织、软件系统的各个部分的用法以及物理表现（代码和数据库模式等）来设置模型的边界。在这些边界中严格保持模型的一致性，而不要受到边界之外问题的干扰和混淆。
4. 开发统一的系统（无论规模大小）需要维持很高的沟通水平，而这一点常常很难做到。我们需要运用各种方法来增进沟通并减小复杂性。还需要一些安全防护措施，以避免过于谨慎的行为（例如，开发人员由于担心破坏现有代码而重复开发一些功能）。
5. Continuous Integration是指把一个上下文中的所有工作足够频繁的合并到一起，并使它们保持一致，以便当模型发生分裂时，可以迅速发现并纠正问题。像领域驱动设计中的其他方法一样，Continuous Integration也有两个级别的操作：a、模型概念的集成 b、实现的集成
6. 建立一个把所有代码和实现工件频繁地合并到一起的过程，并通过自动化测试来快速查明模型的分裂问题。严格坚持使用UbiquitousLanguage，以便在不同人的头脑中演变出不同的概念时，使所有人对模型都能达成一个共识。
7. 其他团队中的人员并不是十分清楚Context的边界，他们会不知不觉地做出一些更改，从而使边界变得模糊或者使互连变得复杂。当不同的上下文必须互相连接时，它们可能会互相重叠。Bounded Context之间的代码重用是很危险的，应该避免。功能和数据的集成必须要通过转换去实现。通过定义不同上下文之间的关系，并在项目中创建一个所有模型上下文的全局视图，可以减少混乱。
8. 识别在项目中起作用的每个模型，并定义其Bounded Context。这包括非面向对象子系统的隐含模型。为每个Bounded Context明明，并把名称添加到Ubiquitous Language中。描述模型之间的联系点，明确所有通信需要的转换，并突出任何共享的内容。想将当前的情况描绘出来，以后再做改变。
9. 从领域模型中选出两个团队都同意共享的一个子集。当然，除了这个模型子集以外，还包括与该模型部分相关的代码子集，或数据库设计的子集。这部分明确共享的内容具有特殊的地位，一个团队在没有另一个团队上了的情况下不应擅自更改它。功能系统要经常进行集成，但集成的频率应该比团队中Continuous Integration的频率低一些。在进行这些集成的时候，两个团队都要运行测试。这是一个仔细的平衡。Shared Kernel（共享内核）不能像其他设计部分那样自由更改。在做决定时需要与另一个团队协商。共享内核中必须集成自动测试套件，因为修改共享内核时，必须要通过两个团队的所有测试。
10. 我们常常会碰到这样的情况：一个子系统主要服务于另一个子系统，依赖是单向的；上游和下游子系统很自然地分隔到两个Bounded Context中，转换很容易，因为只需要单向转换，但两个团队的行政组织关系可能会引起问题。如果下游团队对变更具有否决权，或请求变更的程序太复杂，那么上游团队的开发自由度就会收到限制。由于担心破坏下游系统，上游团队甚至会受到抑制。下游团队依赖于上游团队，但上游团队却不负责下游团队的产品交付。要琢磨拿什么来影响对方团队呢，是人性呢，还是事件压力，抑或其他诸如此类的，这需要耗费大量额外的精力。因此，正式规定团队之间的关系会使所有人工作起来更容易。
11. 在两个团队之间建立一种明确的客户/供应商关系。在计划会议中，下游团队相当于上游团队的客户。根据下游团队的需求来协商需要执行的任务并为这些任务做预算，以便每个人都知道双方的约定和进度。在迭代期间，下游团队成员应该像传统客户一样随时回答上游团队的疑问，并帮助解决问题。
12. 当两个具有上游/下游关系的图阿奴地不归同一个管理者指挥时，Customer/Supplier Team这样的合作模式就不会奏效。如果上游团队没有动力来满足下游团队的需求，那么下游团队将无能为力。出于利他主义的考虑，上游开发人员可能会做出承诺，但他们可能不会履行承诺。下游团队出于良好的意愿可能会相信这些承诺，从而根据一些永远不会实现的特性来指定计划，下游项目只能被搁置。在这种情况下，有3中可能的途径：a、完全放弃对上游的使用 b、下游开发资金的模型，并承担起开发转换层的全部责任 c、严格遵守上游团队的模型 -- 通过严格遵守上游的模型，可以消除在Bounded Context之间进行转换的复杂性。尽管这会限制下游设计人员的风格，而且可能不会得到理想的应用程序，但选择Conformity模式可以极大的简化集成。
13. 创建一个隔离层，以便根据客户自己的领域模型来为客户提供相关功能。这个层通过另一个系统现有接口与其进行对话，而只需对那个系统作出很少的修改，甚至无需修改。在内部，这个层在两个模型之间进行必要的双向转换。
14. 当一个子系统必须与大量其他系统进行集成时，为每个集成都定制一个转换层可能会减慢团队的工作速度，需要维护的东西会越来越多。如果一个子系统有某种内聚性，或许可以把它描述为一组Service，这组Servie满足了其他子系统的公共需求。


第十五章 精炼
1. 精炼是把一堆混杂在一起的组件分开的过程，以便通过某种形式从中提取出最重要的内容，而这种形式将使它更有价值，也更有用。模型就是知识的精炼。通过每次重构所得到的更深层的理解，我们得以把关键的领域知识和优先级提取出来。精炼的主要动机是把最有价值的那部分提取出来，正是这部分使我们的软件区别于其他软件并让整个软件的构建物有所值，这个部分就是Core Domain
2. 领域模型的战略精炼包括以下部分：a、帮助所有团队成员掌握系统的总体设计以及各部分如何协调工作 b、找到一个具有适度规模的核心模型并把它添加到通用语言中，从而促进沟通 c、指导重构 d、专注于模型中最有价值的那部分 e、指导外包、现成组件的使用以及人物委派
3. 一个严峻的现实是我们不可能对所有设计部分进行同等的精化，而是必须分出优先级。但本来就稀缺的高水平开发人员往往会把工作重点放在技术基础实施上，或者只去解决那些不需要专门领域知识就能理解的领域问题。他们认为通过这些工作可以让自己具备一些在其他地方也能派上用场的专业技能，同时丰富了个人简历。而真正体现应用程序价值并且使之成为业务资产的领域核心确实由那些技术水平稍差的开发人员完成的，他们与DBA仪器创建数据模式，然后逐个特性编写代码，而根本没有对模型的概念能力加以任务利用。如果软件的这个部分实现得很差，那额无论技术基础设施有多好，无论支持功能有多完善，应用程序永远都不会为用户提供真正有吸引力的功能。这个严重问题的根源在于项目没有一个明确的整体设计图，而且也没有认清各个部分的相对重要性。
4. 对模型进行提炼。找到Core Domain并提供一种易于区分的方法把它与那些起辅助作用的模型和代码分开。最有价值和最专业的概念要轮廓分明。尽量压缩Core Domain。让最有才能的人来开发Core Domain，并据此要求进行相应的招聘。在Core Domain中努力开发能够确保实现系统蓝图的深层模型和柔性设计。仔细判断任何其他部分的投入，看它是否能够支持这个提炼出来的Core。
5. 在项目团队中，技术能力最强的人员往往缺乏丰富的领域知识。这限制了他们的作用，并且更倾向于分派他们来开发一些支持组件，从而形成了一个恶性循环 -- 知识的缺乏使他们远离了那些能够学到领域知识的工作。打破这种恶心循环是很重要的，方法是建立一支由开发人员和以为或多维领域专家组成的联合团队，其中开发人员必须能力很强、能够长期稳定地工作并且对学习领域知识非常感兴趣，而且领域专家则要掌握深厚的业务知识。如果你认真对待领域设计，那么它就是一项有趣且充满技术挑战的工作。你肯定也会找到持这种观点的人。从外界聘请一些短期的专业人员设计Core Domain的关键环节通常是行不通的，因为团队需要积累领域知识，而短期人员会造成知识流失。相反，充当培训和指导角色的专家可能非常有价值，因为他们帮助团队建立领域设计技巧，并促进团队成员使用尚未掌握的高级设计原则。
6. 识别出那些与项目意图无关的内聚子领域。把这些子领域的通用模型提取出来，并放到单独的Module中。任何专有的东西都不应该放在这些模块中。把它们分离出来以后，在继续开发的工程中，它们的优先级应低于Core Domain的优先级，并且不要分派核心开发人员来完成这些任务（因为它们很少能够从这些任务中获得领域知识）。此外，还可以考虑为这些Generic Subdomain使用现成的解决方案或“公开发布的模型”（Published Model）。当开发这样的软件包时，有以下几种选择：a、现成的解决方案 b、公开发布的设计或模型 c、把实现外包出去 d、内部实现
7. 通用不等于可重用。现成的解决方案可能适用于某种特殊情况，也可能不适用，但假设你要自己实现代码（内部实现或外包出去），那么不要特别关注代码的可重用性。因为那样做会违反精练的基本动机 -- 我们应该尽可能把大部分精力投入到Core Domain中。重用确实会发生，但不一定总是代码重用。模型重用通常是更高级的重用。尽管我们很少需要考虑设计的可重用性，但通用子领域的设计必须严格地限定在通用概念的范围之内。
8. 敏捷过程通常要求通过尽早解决最具风险的任务来管理风险。特别是XP过程，它要求迅速建立并运行一个端到端的系统。这种初步的系统通常用来检验某种技术架构，而且人们会试图建立一个外围系统，用来处理一些支持性的Generic Subdomain，因为这些子领域通常更易于分析。但这不利于风险管理。端到端的系统是实际系统中最困难部分的“雏形” -- 它控制风险的能力也仅限于此。当使用这种雏形时，我们很容易嘀咕领域建模的风险。这种风险包括未预料到存在的复杂性、与业务专家的交流不够充分，或者开发人员的关键技能存在欠缺等。因此，除非团队拥有精湛的技术并且对领域非常熟悉，否则第一个雏形系统应该以Core Domain的某个部分作为基础，不管它有多么简单。相同的原则也适用于把任何试图把高风险的任务放到前面处理的过程。Core Domain就是高风险的额，因为它的难度往往会超出我们的预料，如果没有它，项目就不可能获得成功。
9. Domain Version Statement -- 写一份Core Domain的简短描述（大约一页纸）以及它将会创造的价值，也就是“价值主张”。那些不能将你的领域模型与其他领域模型区分开的方面就不要写了。展示出领域模型时如何实现和均衡各方利益的。这份描述要尽量精简。尽早把它写出来，随着新的理解随时修改它。Domain Version Statement可以用作一个指南，它帮助开发团队在精炼模型和代码的过程中保持统一的方向。团队的非技术成员、管理层甚至客户也都可以共享领域愿景说明（当然，包含专有信息的情况除外）。
10. 精炼文档 -- 编写一个非常简短的文档（3-7页，每页内容不必太多），用于描述Core Domain以及Core元素之间的主要交互过程。精炼文档应该能够被团队中的非技术人员理解。把它当做一个共享的视图，描述每个人都应该知道的东西，而且可以把它作为团队所有成员研究模型和代码的一个起点。
11. 如果精炼文档概括了Core Domain的核心元素，那么它就可以作为一个指示器 -- 用以指示模型改变的重要程度。当模型或代码的修改影响到精炼文档时，需要与团队其他成员一起协商。当对精炼文档做出修改时，需要立即通知所有团队成员，而且要把新版本的文档分发给他们。Core外部的修改或精炼文档外部的细节修改则无需协商或通知，可以直接把它们集成到系统中，其他成员在后续工作中自然会看到这些修改。这样开发人员就拥有了XP所建议的完全的自治性。
12. 封装机制是面向对象设计的一个基本原则。把复杂算法隐藏到方法中，再为方法起一个一看就知道其用途的名字，这样就把“做什么”和“怎么做”分开了。这种技术使设计更易于理解和使用。然而他也有一些先天的局限性。计算有时会非常复杂，使设计开始变得膨胀。机械性的“如何做”大量增加，把概念性的“做什么”完全掩盖了。为解决问题提供算法的大量方法掩盖了那些用于表达问题的方法。
13. 把概念上的Cohesive Mechanism（内聚机制）分离到一个单独的轻量级框架中。要特别注意公式或那些有完备文档的算法。用一个Intention-Revealing Interface来暴露这个框架的功能。现在，领域中的其他元素就可以只专注于如何表达问题（做什么）了，而把解决方案的复杂细节（如何做）转移给了框架。然后，这些被分离出来的机制承担起支持的任务，从而留下一个更小的、表达得更清楚的Core Domain，这个核心以更加声明式的方式通过接口来使用这些机制。
14. 模型中元素可能有一部分属于Core Domain，而另一部分起支持作用。核心元素可能与一般元素紧密耦合在一起。Core的概念内聚性可能不是很强，看上去也不明显。这种混乱性和耦合关系抑制了Core。设计人员如果无法清晰地看到最重要的关系，就会开发出脆弱的设计。因此：对模型进行重构，把核心概念从支持性元素（包括定义得不清楚的那些元素）中分离出来，并增强Core的内聚性，同时减少它与其他代码的耦合。把所有通用元素或支持性元素提取到其他对象中，并把这些对象放到其他的包中 -- 即使这会把一些紧密耦合的元素分开。
15. Abstract Core：我们处理大模型的方法通常是把它分解为足够小的子领域，以便能够掌握它们并把它们放到一些独立的Module中。当不同Module的子领域之间大量交互时，要么需要在Module之间创建很多引用，这在很大程度上抵消了划分模块的价值；要么就必须间接地实现这些交互，而后者会使模型变得晦涩难懂。这里不妨采用横向切割而不是纵向切割的方式。多态性允许我们忽略抽象实例的很多细节变化。如果Module之间的大部分交互都可以在多态接口这个层析上表示出来，那么久可以把这些类型重构到一个特定的Core Module中。因此，把模型中最基本的概念识别出来，并分离到不同的类、抽象类、或接口中。设计这个抽象模型，使之能够表达出重要组件之间的大部分交互。把整个完整的抽象模型放到它自己的Module中，而专用的、详细的实现则留在由子领域定义的Module中。


第十六章 大型结构
1. 在一个大的系统中，如果因为缺少一种全局性的原则而使人们无法根据元素在模式（这些模式被应用于整个设计）中的角色来解释这些元素，那么开发人员就会陷入“只见树木，不见森林”的境地。  我们需要理解各个部分在整体中的角色，而不必去探究细节。设计一种应用于整个系统的规则（或角色和关系）模式，使人们可以通过它在一定程度上了解各个部分在整体中所处的位置（即使是在不知道各个部分的详细职责的情况下）。
2. 一个没有任何规则的随意设计会产生一些无法理解整体含义且很难维护的系统。但架构中早期的设计假设优惠使项目变得束手束脚，而且会极大地限制应用程序中某些特定部分的开发人员/设计人员的能力。很快，开发人员就会为适应结构而不得不在应用程序的开发商委屈求全，要么就是完全推翻架构而又回到没有协调的开发老路上来。因此：让这种概念上的大型结构随着应用程序一起演变，甚至可以变成一种完全不同的结构风格。不要一次过分限制详细的设计和模型决策，这些决策和模型决策必须在掌握了详细知识之后才能确定。
3. 软件设计往往非常抽象且难于掌握。开发人员和用户都需要一些切实可行的方式来理解系统，并共享系统的一个整体视图。当系统的一个具体类比正好符合团队成员对系统的想象，并且能够引导他们向着一个有用的方向进行思考时，就应该把这个类比用作一个大型结构。围绕这个隐喻来组织设计，并把它吸收到Ubiquitous Language中。System Metaphor（系统隐喻）应该能促进促进系统的交流，又能指导系统的开发。它可以增加系统不同部分之间的一致性，甚至可以跨越不同的Bounded Contetx。但所有隐喻都不是完全精确的，因此应不断检查隐喻是否过度或不恰当，当发现它起到妨碍作用时，要随时准备放弃它。
4. 一些领域具有自然的层次结构。这种自然的层次结构使我们很容易想到把领域分层，这是最成功的的架构设计模式之一。所谓的层，就是对系统进行划分，每个层的元素都知道或能够使用它“下面”的那些层的服务，但却不知道它“上面”的层，而且与它上面的层保持独立。当我们把Module的依赖性画出来时，图的布局通常是具有依赖性的Module在它所依赖的模块上面。按照这种模式，可以将各层的顺序梳理出来，最终，低层中的对象在概念上不依赖于高层中的对象。
5. 注意观察模型中的概念依赖性，以及领域中的不同部分的变化频率和变化的原因。如果再领域中发现了自然的层次结构，就把它们转换为宽泛的抽象职责。这些职责应该描述系统的高层目的和设计。对模型进行重构，使得每个领域独享、Aggregate和Module的职责都清晰地位于一个职责层中。
6. Knowledge Level是一组描述了另一组对象应该有哪些行为的对象。当我们需要让用户对模型的一部分有所控制，而模型又必须满足更大的一组规则时，可以利用Knowledge Level(知识级别)来处理这种情况。它可以使软件具有可配置的行为，其中实体中的角色和关系必须在安装时（甚至是运行时）进行修改。 Knowledge Level是Reflection（反射）模式在领域层的一种应用，很多软件架构和技术基础设施中都使用了它。Reflection模式能够使软件具有“自我感知”的特性，并使所选中的结构和行为可以接受调整和修改，从而满足变化需要。
7. 创建一组不同的对象，用它们来描述和约束基本模型的结构和行为。把这些对象分为两个级别，一个是非常具体的级别，另一个级别则提供了一些可供用户或超级用户定制的规则和知识。
8. 当很多应用程序需要进行互操作时，如果所有应用程序都基于相同的一些抽象，但它们是独立设计的，那么在多个Bounded Context之间的转换会限制它们的集成。各个团队之间如果不能紧密协作，就无法形成一个Shared Kernel。重复和分裂将会增加开发和安装的成本，而且互操作会变得很难实现。一些成功的项目将它们的设计分解为组件，每个组件负责提供某些类别的功能。通常所有的组件都插入到一个中央hub上，这个hub支持组件所需要的所有协议，并且知道如何与它们所提供的接口进行对话。
9. 从接口和交互中提炼出一个Abstract Core，并创建一个框架，这个框架要允许这些接口的各种不同实现被自由替换。同样，无论是什么应用程序，只要它严格地通过Abstract Core的接口进行操作，那么就可以允许它使用这些组件。
10. 通过重构得到更适当的结构：a、最小化 b、沟通和自律 c、通过重构得到柔性设计 d、通过精炼可以减轻负担

第十七章 领域驱动设计的综合运用
1. 把大型结构与Bounded Context结合起来使用，战略设计的3个基本原则（上下文、精炼和大型结构）并不是可以互相代替的，而是互为补充，并且以多种方式进行互动。例如，一种大型结构可以存在于一个Bounded Context中，也可以跨越多个 Bounded Context存在，并用于组织Context Map。
2. 将大型结构与精炼结合起来使用，大型结构和精炼的该你那也是互为补充的。大型结构可以帮助解释Core Domain内部的关系以及Generic Subdomain之间的关系，同时，大型结构本身也可能是Core Domain的一个重要部分。例如，把潜能层、作业层、策略侧和决策支持层分开，能够提炼出对软件所要解决的业务问题的基本理解。
3. 当对一个项目进行战略设计时，需要先清晰地评估现状： a、画出Context Map。你能画出一个一致的图吗？有没有一些模棱两可的情况？ b、注意项目上的语言使用。有没有Ubiquitous Language？这种语言是否足够丰富，以便帮助开发？ c、理解重点所在。Core Domain被识别出来了吗？有没有Domain Vision Statement？你能写一个吗？ d、项目所采用的技术是遵循 Model-Driven-Design，还是与之相悖？e、团队开发人员是否具备必要的技能？ f、开发人员是否了解领域知识？他们对领域是否感兴趣？
4. 由谁制定策略 a、从应用程序开发自动得出的结构 b、以客户为中心的架构团队
5. 制定战略设计决策的6个要点：a、决策必须传达到整个团队 b、决策过程必须收集反馈意见 c、计划必须允许演变 d、架构团队不必把所有最好的、最聪明的人员都吸引进来 e、战略设计需要遵守简约和谦逊的原则 f、对象的职责要专一，而开发人员应该是多面手































	

